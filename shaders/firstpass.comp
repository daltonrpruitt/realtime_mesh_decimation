#version 430
//#extension GL_Nvshader_atomic_float : enable


#define X %%X%%
#define Y %%Y%%
#define Z %%Z%%

#define NUM_VERTS %%NUM_VERTS%%
#define NUM_TRIS %%NUM_TRIS%%

// Workgroup Sizes
layout(local_size_x=1, local_size_y=1, local_size_z=1) in;


layout(std430, binding=0) buffer inVerts
{
    vec3 vertices[];
};

layout(std430, binding=1) buffer inIndices
{
    uvec3 indices[];
};

layout(std430, binding=2) buffer vert_cluster_id
{
    uint vert_cluster_ids[];
};

//uniform vec3 inIndices[NUM_TRIS]; // NUM_TRIS

layout (std430, binding = 3) buffer quadric_map
{
    vec4 vertex_pos_total[1];
    vec4 quadric_first_4[1];
    vec4 quadric_next_3_plus_1[1];
    vec4 quadric_last_2[1];
};


layout(r32i, binding = 4) uniform iimage2D img_output_normx;
layout(r32i, binding = 5) uniform iimage2D img_output_normy;
layout(r32i, binding = 6) uniform iimage2D img_output_normz;
layout(r32i, binding = 7) uniform iimage2D img_output_dist;

float float_to_int_scaling_factor = 1000000.0;
uniform int resolution;
uint u_resolution = uint(resolution);


void main() {
    uint g_id = gl_GlobalInvocationID.z * u_resolution * u_resolution +
                gl_GlobalInvocationID.y * u_resolution +
                gl_GlobalInvocationID.x;  // Equivalent to cell ID, too
    ivec2 output_index = ivec2(gl_GlobalInvocationID.xy); 
    
    /*
    imageAtomicAdd(img_output_normx, output_index, int(gl_GlobalInvocationID.x)); //vert_cluster_ids[idxs[v]]);// int_normal.x);
    imageAtomicAdd(img_output_normy, output_index, int(gl_GlobalInvocationID.y));
    imageAtomicAdd(img_output_normz, output_index, int(gl_GlobalInvocationID.z));
    imageAtomicAdd(img_output_dist, output_index, int(g_id));
    //*/
    
    // for each triangle
    for (int i=0; i < NUM_TRIS;  i++) {
    
        
        uvec3 idxs = indices[i];

        // Only compute if in current cluster
        if (vert_cluster_ids[idxs[0]] != g_id && vert_cluster_ids[idxs[1]] != g_id && vert_cluster_ids[idxs[2]] != g_id ){
            continue;
        }

        //imageAtomicAdd(img_output_normx, output_index, 1);// .x); // 
    
        
        // At least one vertex in current cell
        vec3 v0 = vertices[idxs[0]];
        vec3 v1 = vertices[idxs[1]];
        vec3 v2 = vertices[idxs[2]];

        // Compute quadric for plane
        vec3 normal = normalize(cross(v1-v0, v2-v0));
        float d = -dot(v0, normal);

        vec3 scaled_normal = normal * float_to_int_scaling_factor; 
        ivec3 int_normal = ivec3(int(scaled_normal.x), int(scaled_normal.y), int(scaled_normal.z));
        int int_dist = int(d * float_to_int_scaling_factor);

        if(vert_cluster_ids[idxs[0]] == g_id){
            imageAtomicAdd(img_output_normx, output_index, int_normal.x); //vert_cluster_ids[idxs[v]]);// int_normal.x);
            imageAtomicAdd(img_output_normy, output_index, int_normal.y);
            imageAtomicAdd(img_output_normz, output_index, int_normal.z);
            imageAtomicAdd(img_output_dist, output_index, int_dist);
        }

        if(vert_cluster_ids[idxs[1]] == g_id){
            imageAtomicAdd(img_output_normx, output_index, int_normal.x); //vert_cluster_ids[idxs[v]]);// int_normal.x);
            imageAtomicAdd(img_output_normy, output_index, int_normal.y);
            imageAtomicAdd(img_output_normz, output_index, int_normal.z);
            imageAtomicAdd(img_output_dist, output_index, int_dist);
        }

        if(vert_cluster_ids[idxs[2]] == g_id){
            imageAtomicAdd(img_output_normx, output_index, int_normal.x); //vert_cluster_ids[idxs[v]]);// int_normal.x);
            imageAtomicAdd(img_output_normy, output_index, int_normal.y);
            imageAtomicAdd(img_output_normz, output_index, int_normal.z);
            imageAtomicAdd(img_output_dist, output_index, int_dist);
        }
        
        
    }
    /*

    /*
    vec3 vertex_sum = vertices[idxs[0]] + vertices[idxs[1]] + vertices[idxs[2]];
    //ivec2 dimens = imageSize(img_output);
    vec4 output_val = vec4(vertex_sum/3.0, -1.0);

    imageStore(img_output, output_index, output_val);
    */
}
